<!DOCTYPE html>
<html>
<head>
    <title>Gezelle Netwerk Visualisatie</title>
    <script type="text/javascript" src="https://unpkg.com/vis-network@9.1.2/standalone/umd/vis-network.min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparser.min.js"></script>
    <style>
        /* CRUCIAAL: De container moet een vaste hoogte en breedte hebben om zichtbaar te zijn */
        #mynetwork {
            width: 100%;
            height: 600px; 
            border: 1px solid lightgray;
            box-shadow: 2px 2px 10px rgba(0,0,0,0.1);
        }
        body { font-family: Arial, sans-serif; padding: 20px; }
        .controls { margin-bottom: 20px; padding: 15px; border: 1px solid #ddd; background-color: #f9f9f9; }
        .controls label, .controls input { margin-right: 20px; }
    </style>
</head>
<body>

    <h1>Netwerk Visualisatie</h1>

    <div class="controls">
        <label for="startYear">Start Jaar:</label>
        <input type="number" id="startYear" value="1870" min="1800" max="1950" onchange="filterAndDraw()">

        <label for="endYear">Eind Jaar:</label>
        <input type="number" id="endYear" value="1890" min="1800" max="1950" onchange="filterAndDraw()">
        
        <p style="margin-top: 10px;">Gefilterde knooppunten: <strong id="nodeCount">0</strong> | Gefilterde randen: <strong id="edgeCount">0</strong></p>
    </div>

    <div id="mynetwork"></div>

    <script type="text/javascript">
        let allNodes = [];
        let allEdges = [];
        let network = null;
        let originalNodesData = null; // Opslag voor de gefilterde, ongewijzigde nodes
        let originalEdgesData = null; // Opslag voor de gefilterde, ongewijzigde edges
        const container = document.getElementById('mynetwork');

        // --- Vis.js Options (Aangepast voor overlapvermijding) ---
        const options = {
            nodes: {
                shape: 'dot',
                font: { size: 12, color: '#333' },
                borderWidth: 2
            },
            edges: {
                arrows: 'to',
                color: { inherit: true },
                smooth: { type: 'continuous' }
            },
            physics: {
                enabled: true, 
                solver: 'forceAtlas2Based', 
                forceAtlas2Based: {
                    gravitationalConstant: -150, 
                    centralGravity: 0.005,
                    springLength: 250,      
                    springConstant: 0.08,   
                    avoidOverlap: 1         
                },
                stabilization: { 
                    enabled: true, 
                    iterations: 100, 
                    fitAfterStabilized: true, 
                    tolerance: 0.001
                }
            }
        };
        // --------------------------------------------------------------------

        // --- Data Laden en Parsen Functies ---
        async function loadData() {
            try {
                // Laden van nodes.csv
                const nodesData = await parseCSV('nodes.csv');
                allNodes = nodesData.map(d => ({
                    id: d.Id, 
                    label: d.Label, 
                    group: d.category, 
                    title: `Naam: ${d.Label}\nType: ${d.category}\nStart: ${d.startyearcorfixvalue}\nEind: ${d.endyearcor}`,
                    startYear: parseInt(d.startyearcorfixvalue), 
                    endYear: parseInt(d.endyearcor),
                    size: parseFloat(d.Size) || 15
                }));

                // Laden van edges.csv
                const edgesData = await parseCSV('edges.csv');
                allEdges = edgesData.map(d => ({
                    id: d.Id, // Edge ID is nodig voor highlighting
                    from: d.Source, 
                    to: d.Target, 
                    label: d.rollabel, 
                    title: `Relatie: ${d.rollabel}\nJaar: ${d.finalstartyearfixvalue}-${d.finalendyearfixvalue}`,
                    startYear: parseInt(d.finalstartyearfixvalue), 
                    endYear: parseInt(d.finalendyearfixvalue)
                }));
                
                filterAndDraw();

            } catch (error) {
                console.error("Fout bij het laden van de bestanden:", error);
                container.innerHTML = "<h2>Data Laadfout: Netwerk is leeg</h2><p>Controleer of de bestanden **'nodes.csv'** en **'edges.csv'** in dezelfde map staan. Druk op F12 en bekijk de **Console** voor gedetailleerde fouten.</p>";
            }
        }

        function parseCSV(url) {
            return new Promise((resolve, reject) => {
                Papa.parse(url, {
                    download: true,
                    header: true,
                    skipEmptyLines: true,
                    complete: (results) => {
                        if (results.errors.length > 0) {
                            reject(results.errors);
                        } else {
                            if (results.data.length === 0) {
                                reject(new Error("Leeg of ongeldig CSV-bestand."));
                            } else {
                                resolve(results.data);
                            }
                        }
                    },
                    error: (error) => reject(error)
                });
            });
        }
        // --------------------------------------------------------------------


        // --- Filtering en Drawing Functies ---
        function filterAndDraw() {
            const startYear = parseInt(document.getElementById('startYear').value);
            const endYear = parseInt(document.getElementById('endYear').value);

            if (isNaN(startYear) || isNaN(endYear)) return;

            const filteredEdges = allEdges.filter(edge => {
                return edge.startYear <= endYear && edge.endYear >= startYear;
            });

            const connectedNodeIds = new Set();
            filteredEdges.forEach(edge => {
                connectedNodeIds.add(edge.from);
                connectedNodeIds.add(edge.to);
            });

            const filteredNodes = allNodes.filter(node => {
                return connectedNodeIds.has(node.id);
            });
            
            document.getElementById('nodeCount').textContent = filteredNodes.length;
            document.getElementById('edgeCount').textContent = filteredEdges.length;

            // Sla de ongewijzigde data op voor de click handler
            originalNodesData = new vis.DataSet(filteredNodes);
            originalEdgesData = new vis.DataSet(filteredEdges);

            const data = {
                nodes: originalNodesData,
                edges: originalEdgesData
            };

            if (network) {
                network.setData(data);
            } else {
                network = new vis.Network(container, data, options);
                // Koppel de click handler nadat het netwerk is gemaakt
                network.on("click", handleNodeClick);
            }
        }
        // --------------------------------------------------------------------


        // --- Nieuwe Click Handler Functie (de oplossing) ---
        function handleNodeClick(params) {
            // Als er niets is aangeklikt of als er op een rand is geklikt, reset de weergave
            if (params.nodes.length === 0) {
                network.setData({
                    nodes: originalNodesData,
                    edges: originalEdgesData
                });
                return; 
            }

            const selectedNodeId = params.nodes[0];
            const connectedEdges = network.getConnectedEdges(selectedNodeId);
            
            // 1. Zoek alle verbonden nodes (neighbours)
            const connectedNodeIds = new Set();
            connectedEdges.forEach(edgeId => {
                const edge = originalEdgesData.get(edgeId);
                // Voeg de bron- en doel-node toe, behalve de geselecteerde node zelf
                if (edge.from !== selectedNodeId) connectedNodeIds.add(edge.from);
                if (edge.to !== selectedNodeId) connectedNodeIds.add(edge.to);
            });

            // 2. Wijzig de stijl van alle nodes
            const allNodeUpdates = originalNodesData.map(node => {
                const isSelected = node.id === selectedNodeId;
                const isConnected = connectedNodeIds.has(node.id);
                
                let update = {};

                if (isSelected || isConnected) {
                    // Geselecteerde en verbonden nodes: Lichter, groter (optioneel), vol.
                    update = {
                        id: node.id,
                        opacity: 1.0,
                        color: node.color, // Gebruik de originele kleur
                        // Optioneel: Border laten oplichten of size vergroten
                        borderWidth: isSelected ? 3 : 2
                    };
                } else {
                    // NIET verbonden nodes: Donkerder en fletser.
                    update = {
                        id: node.id,
                        opacity: 0.3,
                        color: { background: '#ccc', border: '#999' } // Grijs en flets
                    };
                }
                return update;
            });

            // 3. Wijzig de stijl van alle edges
            const allEdgeUpdates = originalEdgesData.map(edge => {
                const isConnected = connectedEdges.includes(edge.id);
                let update = { id: edge.id };

                if (isConnected) {
                    // Verbonden randen: Volle kleur, dikkere lijn
                    update.width = 3;
                    update.color = { color: edge.color || '#333', opacity: 1.0 };
                } else {
                    // NIET verbonden randen: bijna onzichtbaar
                    update.width = 1;
                    update.color = { color: '#ccc', opacity: 0.1 };
                }
                return update;
            });

            // 4. Update de dataSet met de nieuwe stijlen
            const updatedNodes = new vis.DataSet(allNodeUpdates);
            const updatedEdges = new vis.DataSet(allEdgeUpdates);

            network.setData({
                nodes: updatedNodes,
                edges: updatedEdges
            });
        }
        // --------------------------------------------------------------------

        // Start het proces
        loadData();
    </script>

</body>
</html>